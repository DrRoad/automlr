
 - [X] error when task has weights
 - [X] return NULL and warning when searchspace is empty
 - [-] learners that are selected depend on learner type and task type:
   - [X] task is multiclass -- all the twoclass learners missing
   - [ ] task is class -- all regression learners missing
   - [ ] task is regression -- all the task learners missing
   - [X] task has NAs -- all the learners that can't handle them missing
   - [X] task has factors -- all the learners that can't handle them missing
   - [X] task has ordereds -- all the learners that can't handle them missing
   - [X] task has NAs, factors, ordereds, but a requiredwrapper that can convert them -- the learners are not missing
   - [X] task has NAs, factors, ordereds, but a nonrequired wrapper that can handle them: ignored
   - [X] task has no numerics but factors or ordereds: learners that can only handle numerics go out
   - [X] task has no numerics but factors or ordereds, and requiredwrapper that can convert: learners that can only handle numerics stay in
 - [X] no valid learner found --> warning received, return NULL
 - [ ] search space parameter behaviour
   - [ ] parameter definition consistency
     - [ ] parameter is dummy and 'fix' -> warning (or error?)
     - [ ] parameter is dummy and 'def' -> error
     - [ ] parameter is inject and 'def' -> error
   - [ ] id behaviour
     - [ ] parameter has an id but is the only one -> warning, but nothing special
     - [ ] two parameters have same id but different type/length/feasible region -> error
   - [ ] .AMLRFIX definitions
     - [ ] .AMLRFIX without requirements -> error
     - [ ] .AMLRFIX, but other parameter has no requirements -> error
     - [ ] .AMLRFIX with "fix" or "def" type -> error
     - [ ] .AMLRFIX but other parameter has "fix" or "def" -> error
     - [ ] .AMLRFIX but itself / other parameter is 'dummy' -> error
     - [ ] .AMLRFIX and itself / other is 'inject' --> works
   - [ ] parameter definitions match learner
     - [ ] learner has parameter that is not part of search space -> warning
     - [ ] 'inject' but parameter exists really -> error
     - [ ] 'dummy' but parameter exists -> error
     - [ ] parameter neither dummy nor inject (any type or 'def' or 'fix') not present in searchspace -> error
     - [ ] parameter neither dummy nor inject (any type or def or fix) has value that is partially infeasible for true param -> error
     - [ ] parameter neither dummy nor inject (any type, not def or fix) has type that is incompatible with param (real when int/cat, int when cat) -> error
     - [ ] parameter neither dummy nor inject (any type) has type that is compatible (int/cat when real, cat when int/bool) -> warning
     - [ ] parameter def unlike true def -> warning; learner then receives the given value
     - [ ] parameter def like true def but set hyperpar present -> warning, learner receives the given value or nothing (we don't care)
     - [ ] true param has requires, searchspace param does not -> warning
   - [ ] parameter trafo
     - [ ] parameter with trafo fn: trafo function 'works'
     - [ ] parameter with trafo 'exp': trafo is given. test trafo with known values
   - [ ] outer searchspace appearance
     - [ ] 'inject' parameter is visible from the outside
     - [ ] .AMLRFIX becomes part of searchspace
     - [ ] fixed .AMLRFIX not visible from the outside
     - [ ] parameter fix/def -> not in searchspace
     - [ ] parameter not fix/def -> part of searchspace
     - [ ] parameter is inject and 'fix' -> not visible from the outside
     - [ ] parameter is 'inject' or 'dummy' and of type real/int/cat -> created numeric/integer/discrete(vector)
     - [ ] parameters with only one possible value not visible
   - [ ] inner parameter values
     - [ ] 'dummy', parameter not visible during either training or testing
     - [ ] 'inject' parameter is present during training (and testing?)
     - [ ] parameter .AMLRFIX reaches learner as normal value
       - [ ] .AMLRFIX reaches learner as fixed value when requirement of a fixed .AMLRFIX given
       - [ ] .AMLRFIX reaches learner as appropriate outside value requirement of a variable .AMLRFIX given
       - [ ] error when two .AMLRFIX requirements are satisfied simultaneously
     - [ ] parameter def is null, true def is null -> learner receives no value
     - [ ] parameter fix -> learner receives this value
     - [ ] parameter is inject and 'fix' -> reaches learner like this
     - [ ] parameters with only one possible value take this value
 - [ ] wrappers
   - [ ] no wrappers given, or only one required wrapper given: no wrapper selector; otherwise there is a selector
   - [ ] one required wrapper: is always used
   - [ ] one nonrequired wrapper: is only used some of the time
   - [ ] two required wrappers: order can be selected; also changes in reallife
   - [ ] two optional wrappers: selector, which one is used and the order match
   - [ ] two optional, two requireds: selector, order and which one is used match
 - [ ] has.X, removes.X
   - [ ] has.X:
     - [ ] parameters in learner can depend on 'has.X'. X may be missings, factors, ordered but not numerics. this is so for
       - [ ] .AMLRFIX
         - [ ] parameters with .AMLRFIX, fixed: value takes on this value in presence/absence of X
         - [ ] parameters with .AMLRFIX, variable: two external vars, each only valid some times, set the goal variable differently inside the learner.
       - [ ] normal variables
         - [ ] removed (or requirement removed) if it trivially depends on has.X / removes.X and requirement satisfied n / y
     - [ ] how variable
       - [ ] is fixed to NO if the task doesn't have X to begin with
       - [ ] is fixed to YES if the task has it an nothing can convert
       - [ ] there is an external var determining this if X is in the task and a wrapper can remove it
       - [ ] there is another var only available if the above is TRUE, determining which wrapper removes it, if more than one wrapper are present
       - [ ] removes.X is set for the given wrapper. this has influence on .AMLRFIX for fixed and variable learners and changes the external search space accordingly, while setting internally the variable accordingly
       - [ ] has.X is true for all the wrappers before and including the one removing it, is false afterwards; .AMLRFIX etc. behaves accordingly
 - [ ] requirements behaviour
   - [ ] parameters with requirements: given requirements are respected, plus 'selected.learner'. (how to test this?) This even works if 'c()' is used an 'c' parameter exists.
   - [ ] requirements consistency
     - [ ] requirements satisfied: generate a random searchspace for a huge setting of wrappers & learners with entanglement of requirements; check internally that these equirements are always satisfied.
     - [ ] requirements satisfied REVERSE: generate the same huge thing; generate variables from the inside and see they are feasible from the outside. THIS MIGHT BE HARD.
   - [ ] requirements simplification
     - [ ] requirements that are always TRUE removed (for wrappers)
     - [ ] parameters with requirements that are always FALSE removed (wrappers and learners)
   - [ ] hidden variables requirements propagation, traversing multiple edges
     - [ ] var reqs can depend on dummy variable values
     - [ ] var reqs can depend on fixed variable values
     - [ ] var reqs can depend on .AMLRFIX fixed var values
     - [ ] var reqs can depend on .AMLRFIX variable var values
   - [ ] circular dependencies cause error

